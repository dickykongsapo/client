///
/// Copyright Â© 2016-2021 The Thingsboard Authors
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///

import { isEqual } from "@app/core/utils";
import { AlarmInfo, AlarmSearchStatus, AlarmSeverity } from "@models/alarm.models";
import { AliasFilterType, EntityFilters } from "@models/alias.models";
import { EntityId } from "@models/id/entity-id";
import { PageData } from "@models/page/page-data";
import { DataKeyType, EntityInfo, EntityType } from "@models/public-api";
import { Datasource, DatasourceType } from "@models/widget.models";

export enum EntityKeyType {
    ATTRIBUTE = 'ATTRIBUTE',
    CLIENT_ATTRIBUTE = 'CLIENT_ATTRIBUTE',
    SHARED_ATTRIBUTE = 'SHARED_ATTRIBUTE',
    SERVER_ATTRIBUTE = 'SERVER_ATTRIBUTE',
    TIME_SERIES = 'TIME_SERIES',
    ENTITY_FIELD = 'ENTITY_FIELD',
    ALARM_FIELD = 'ALARM_FIELD',
    CONSTANT = 'CONSTANT',
    COUNT = 'COUNT'
}


export function dataKeyTypeToEntityKeyType(dataKeyType: DataKeyType): EntityKeyType {
    switch (dataKeyType) {
        case DataKeyType.timeseries:
            return EntityKeyType.TIME_SERIES;
        case DataKeyType.attribute:
            return EntityKeyType.ATTRIBUTE;
        case DataKeyType.function:
            return EntityKeyType.ENTITY_FIELD;
        case DataKeyType.alarm:
            return EntityKeyType.ALARM_FIELD;
        case DataKeyType.entityField:
            return EntityKeyType.ENTITY_FIELD;
        case DataKeyType.count:
            return EntityKeyType.COUNT;
    }
}

export enum EntityKeyValueType {
    STRING = 'STRING',
    NUMERIC = 'NUMERIC',
    BOOLEAN = 'BOOLEAN',
    DATE_TIME = 'DATE_TIME'
}

export enum FilterPredicateType {
    STRING = 'STRING',
    NUMERIC = 'NUMERIC',
    BOOLEAN = 'BOOLEAN',
    COMPLEX = 'COMPLEX'
}

export enum StringOperation {
    EQUAL = 'EQUAL',
    NOT_EQUAL = 'NOT_EQUAL',
    STARTS_WITH = 'STARTS_WITH',
    ENDS_WITH = 'ENDS_WITH',
    CONTAINS = 'CONTAINS',
    NOT_CONTAINS = 'NOT_CONTAINS'
}




export enum NumericOperation {
    EQUAL = 'EQUAL',
    NOT_EQUAL = 'NOT_EQUAL',
    GREATER = 'GREATER',
    LESS = 'LESS',
    GREATER_OR_EQUAL = 'GREATER_OR_EQUAL',
    LESS_OR_EQUAL = 'LESS_OR_EQUAL'
}


export enum BooleanOperation {
    EQUAL = 'EQUAL',
    NOT_EQUAL = 'NOT_EQUAL'
}


export enum ComplexOperation {
    AND = 'AND',
    OR = 'OR'
}



export enum DynamicValueSourceType {
    CURRENT_TENANT = 'CURRENT_TENANT',
    CURRENT_CUSTOMER = 'CURRENT_CUSTOMER',
    CURRENT_USER = 'CURRENT_USER',
    CURRENT_DEVICE = 'CURRENT_DEVICE'
}
export interface EntityKey {
    type: EntityKeyType;
    key: string;
}
export enum Direction {
    ASC = 'ASC',
    DESC = 'DESC'
}
export interface EntityDataSortOrder {
    key: EntityKey;
    direction: Direction;
}

export interface EntityDataPageLink {
    pageSize: number;
    page: number;
    textSearch?: string;
    sortOrder?: EntityDataSortOrder;
    dynamic?: boolean;
}

export interface KeyFilterPredicateUserInfo {
    editable: boolean;
    label: string;
    autogeneratedLabel: boolean;
    order?: number;
}


export interface DynamicValue<T> {
    sourceType: DynamicValueSourceType;
    sourceAttribute: string;
    inherit?: boolean;
}
export interface FilterPredicateValue<T> {
    defaultValue: T;
    userValue?: T;
    dynamicValue?: DynamicValue<T>;
}


export interface KeyFilterPredicateInfo {
    keyFilterPredicate: KeyFilterPredicate;
    userInfo: KeyFilterPredicateUserInfo;
}

export interface EntityCountQuery {
    entityFilter: EntityFilter;
    keyFilters?: Array<KeyFilter>;
}


export interface AbstractDataQuery<T extends EntityDataPageLink> extends EntityCountQuery {
    pageLink: T;
    entityFields?: Array<EntityKey>;
    latestValues?: Array<EntityKey>;
}

export interface EntityDataQuery extends AbstractDataQuery<EntityDataPageLink> {
}


export interface AlarmDataQuery extends AbstractDataQuery<AlarmDataPageLink> {
    alarmFields?: Array<EntityKey>;
}



export interface EntityData {
    entityId: EntityId;
    latest: { [entityKeyType: string]: { [key: string]: TsValue } };
    timeseries: { [key: string]: Array<TsValue> };
}

export interface KeyFilter {
    key: EntityKey;
    valueType: EntityKeyValueType;
    value?: string | number | boolean;
    predicate: KeyFilterPredicate;
}

export type KeyFilterPredicate = StringFilterPredicate |
    NumericFilterPredicate |
    BooleanFilterPredicate |
    ComplexFilterPredicate |
    ComplexFilterPredicateInfo;

export interface StringFilterPredicate {
    type: FilterPredicateType.STRING;
    operation: StringOperation;
    value: FilterPredicateValue<string>;
    ignoreCase: boolean;
}

export interface NumericFilterPredicate {
    type: FilterPredicateType.NUMERIC;
    operation: NumericOperation;
    value: FilterPredicateValue<number>;
}

export interface BooleanFilterPredicate {
    type: FilterPredicateType.BOOLEAN;
    operation: BooleanOperation;
    value: FilterPredicateValue<boolean>;
}


export interface BaseComplexFilterPredicate<T extends KeyFilterPredicate | KeyFilterPredicateInfo> {
    type: FilterPredicateType.COMPLEX;
    operation: ComplexOperation;
    predicates: Array<T>;
}

export type ComplexFilterPredicate = BaseComplexFilterPredicate<KeyFilterPredicate>;

export type ComplexFilterPredicateInfo = BaseComplexFilterPredicate<KeyFilterPredicateInfo>;


export interface EntityFilter extends EntityFilters {
    type?: AliasFilterType;
}

export interface KeyFilter {
    key: EntityKey;
    valueType: EntityKeyValueType;
    value?: string | number | boolean;
    predicate: KeyFilterPredicate;
}


export interface AlarmDataPageLink extends EntityDataPageLink {
    startTs?: number;
    endTs?: number;
    timeWindow?: number;
    typeList?: Array<string>;
    statusList?: Array<AlarmSearchStatus>;
    severityList?: Array<AlarmSeverity>;
    searchPropagatedAlarms?: boolean;
}

export interface TsValue {
    ts: number;
    value: string;
}

export interface AlarmData extends AlarmInfo {
    entityId: string;
    latest: { [entityKeyType: string]: { [key: string]: TsValue } };
}


export function entityKeyTypeToDataKeyType(entityKeyType: EntityKeyType): DataKeyType {
    switch (entityKeyType) {
        case EntityKeyType.ATTRIBUTE:
        case EntityKeyType.CLIENT_ATTRIBUTE:
        case EntityKeyType.SHARED_ATTRIBUTE:
        case EntityKeyType.SERVER_ATTRIBUTE:
            return DataKeyType.attribute;
        case EntityKeyType.TIME_SERIES:
            return DataKeyType.timeseries;
        case EntityKeyType.ENTITY_FIELD:
            return DataKeyType.entityField;
        case EntityKeyType.ALARM_FIELD:
            return DataKeyType.alarm;
        case EntityKeyType.COUNT:
            return DataKeyType.count;
    }
}

export function entityPageDataChanged(prevPageData: PageData<EntityData>, nextPageData: PageData<EntityData>): boolean {
    const prevIds = prevPageData.data.map((entityData) => entityData.entityId.id);
    const nextIds = nextPageData.data.map((entityData) => entityData.entityId.id);
    return !isEqual(prevIds, nextIds);
}

export interface KeyFilterInfo {
    key: EntityKey;
    valueType: EntityKeyValueType;
    value?: string | number | boolean;
    predicates: Array<KeyFilterPredicateInfo>;
}

export interface FilterInfo {
    filter: string;
    editable: boolean;
    keyFilters: Array<KeyFilterInfo>;
}

export interface Filter extends FilterInfo {
    id: string;
}

export interface Filters {
    [id: string]: Filter;
}

export function entityDataToEntityInfo(entityData: EntityData): EntityInfo {
    const entityInfo: EntityInfo = {
        id: entityData.entityId.id,
        entityType: entityData.entityId.entityType as EntityType
    };
    if (entityData.latest && entityData.latest[EntityKeyType.ENTITY_FIELD]) {
        const fields = entityData.latest[EntityKeyType.ENTITY_FIELD];
        if (fields.name) {
            entityInfo.name = fields.name.value;
        } else {
            entityInfo.name = '';
        }
        if (fields.label) {
            entityInfo.label = fields.label.value;
        } else {
            entityInfo.label = '';
        }
        entityInfo.entityDescription = '';
        if (fields.additionalInfo) {
            const additionalInfo = fields.additionalInfo.value;
            if (additionalInfo && additionalInfo.length) {
                try {
                    const additionalInfoJson = JSON.parse(additionalInfo);
                    if (additionalInfoJson && additionalInfoJson.description) {
                        entityInfo.entityDescription = additionalInfoJson.description;
                    }
                } catch (e) { }
            }
        }
    }
    return entityInfo;
}

export function updateDatasourceFromEntityInfo(datasource: Datasource, entity: EntityInfo, createFilter = false) {
    datasource.entity = {
        id: {
            entityType: entity.entityType,
            id: entity.id
        }
    };
    datasource.entityId = entity.id;
    datasource.entityType = entity.entityType;
    if (datasource.type === DatasourceType.entity || datasource.type === DatasourceType.entityCount) {
        datasource.entityName = entity.name;
        datasource.entityLabel = entity.label;
        datasource.name = entity.name;
        datasource.entityDescription = entity.entityDescription;
        datasource.entity.label = entity.label;
        datasource.entity.name = entity.name;
        if (createFilter) {
            datasource.entityFilter = {
                type: AliasFilterType.singleEntity,
                singleEntity: {
                    id: entity.id,
                    entityType: entity.entityType
                }
            };
        }
    }
}